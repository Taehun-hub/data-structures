# data-structures 1주차
자료구조,알고리즘 시간 복잡도
1. 모든 입력에 대해 기본연산 횟수를 더한 후 평균
    -> 현실적으로 불가능함
2. 가장 안 좋은 입력(Worstcase input)에 대란 기본 연산 횟수를 측정(Worstcase time complexity)
    -> 어떤 입력에 대해서도 W.T.C보다 수행시간이 크지 않음
    -> 여러 코드중 최악의 경우의 입력에대한 기본연산횟수가 작은것을 선택
    -> Big-O 표기
    -> 함수값을 결정하는 최고차항만으로 간단하게 표기
         1.최고차항만 남기기
         2.최고차항 계수(상수)는 생략
         3.Big-O(최고차항)
         Ex)
         T1(n) = 2n-1 -> T1(n)=O(n)
         T2(n) = 4n+1 -> T2(n)=O(n)
         T3(n) = (2/3)n²-(2/3)n+1 -> T3(n)=O(n²)
         T4(n) = 1 -> T4(n)=O(1)
         T5(n) = c*log2(N)+1 -> T5(n)=O(log2(N))

# data-structures 2주차
배열(array) vs 리스트(list)
- 가장 기본적인 자료구조(순차적)
[list]
A[2]=0, A[2]=A[2]+1 을 했을때 A[2]는 1이라는 새로운 객체 지정
A.append(6): 맨뒤에 6 삽임 == 6이라는 객체가 어딘가에 저장되어 그것을 가르킴
A.coumt(value) == list에서 몇번 등장하는지
용량을 자동조절(dynamic array)

[array]
용량을 초과하면 에러 , 다시 할당해주어야함

차이점 리스트는 각각의 다른 메모리에 저장 (객체)
차이점 C에서는 읽기 쓰기만 가능 파이썬은 다양한 기능
![img.png](img.png)
여기서 A=B로 A를 덮는데 굳이 del 을 사용하는 이유
사실 굳이 사용하지 않아도 됨 -> 파이썬은 가비지컬렉터가 알아서 정리해 줌 
하지만 del 을 써주면 가비지컬렉터에서 힌트를 주는 거임

순차적 자료구조
1.배열,리스트
-index 로 임의의 원소를 접근

2.stack,Queue,Deque
-제한된 접근(삽입,삭제)만 허용 
STACK : LIFO(Last In First Out)
- 1,2,3,4,5 순으로 들어오면 5,4,3,2,1 순으로 나간다
- 삽입: push # O(1) 상수시간
- 삭제: pop # O(1) 상수시간
- top,len # O(1) 상수시간
Queue : FIFO(First In First Out) 
- 1,2,3,4,5 순으로 들어오면 1,2,3,4,5 순으로 나간다
Deque : stack + Queue
- 두개 다 가능 
- Stack ex1에서 코드 구현 보기 가능

3.linked List(연결 리스트)
-저장된 곳에 그 다음곳의 주소까지 같이 저장
-인덱스 접근 X

 